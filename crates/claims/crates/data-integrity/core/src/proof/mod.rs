use std::{collections::BTreeMap, ops::Deref};

use educe::Educe;
use serde::Serialize;
use ssi_claims_core::{Parameters, ValidateProof};
use ssi_crypto::{Error, SignatureVerification};
use ssi_jwk::VerifyingKey;
use ssi_verification_methods::{CowVerificationMethod, ProofPurpose, VerificationMethodVerifier};

use crate::{CryptographicSuite, CryptographicSuiteFor};

#[derive(Educe, Serialize)]
#[serde(bound(serialize = "S: CryptographicSuite"))]
#[educe(Debug(bound("S: std::fmt::Debug")))]
#[educe(Clone(bound("S: Clone")))]
pub struct Proofs<S>(Vec<Proof<S>>);

impl<S> Proofs<S> {
    pub fn new(proof: Proof<S>) -> Self {
        Self(vec![proof])
    }
}

impl<S> Deref for Proofs<S> {
    type Target = [Proof<S>];

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl<S, T, V> ValidateProof<T, V> for Proofs<S>
where
    S: CryptographicSuiteFor<T>,
    V: VerificationMethodVerifier,
{
    async fn validate_proof<'a>(
        &'a self,
        verifier: &'a V,
        claims: &'a T,
        params: &'a ssi_claims_core::Parameters,
    ) -> Result<SignatureVerification, Error> {
        for proof in &self.0 {
            if let Err(e) = proof.verify_with(verifier, claims, params).await? {
                return Ok(Err(e));
            }
        }

        Ok(Ok(()))
    }
}

// mod de;

// mod configuration;
// // mod prepared;
// mod reference;
// mod r#type;

// pub use configuration::*;
// // pub use prepared::*;
// pub use r#type::*;
// pub use reference::*;

/// Data Integrity Proof.
///
/// A data integrity proof provides information about the proof mechanism,
/// parameters required to verify that proof, and the proof value itself.
#[derive(Educe, Serialize)]
#[serde(bound(serialize = "S: CryptographicSuite"))]
#[educe(Debug(bound("S: std::fmt::Debug")))]
#[educe(Clone(bound("S: Clone")))]
#[serde(rename_all = "camelCase")]
pub struct Proof<S> {
    /// Proof context.
    #[serde(rename = "@context", default, skip_serializing_if = "Option::is_none")]
    pub context: Option<ssi_json_ld::syntax::Context>,

    #[serde(flatten, with = "cryptosuite_type")]
    pub r#type: S,

    /// Date a creation of the proof.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created: Option<xsd_types::DateTimeStamp>,

    /// Verification method.
    pub verification_method: CowVerificationMethod,

    /// Purpose of the proof.
    pub proof_purpose: ProofPurpose,

    /// Specifies when the proof expires.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expires: Option<xsd_types::DateTimeStamp>,

    #[allow(rustdoc::bare_urls)]
    /// Conveys one or more security domains in which the proof is meant to be
    /// used.
    ///
    /// A verifier SHOULD use the value to ensure that the proof was intended to
    /// be used in the security domain in which the verifier is operating. The
    /// specification of the domain parameter is useful in challenge-response
    /// protocols where the verifier is operating from within a security domain
    /// known to the creator of the proof.
    ///
    /// Example domain values include: `domain.example`` (DNS domain),
    /// `https://domain.example:8443` (Web origin), `mycorp-intranet` (bespoke
    /// text string), and `b31d37d4-dd59-47d3-9dd8-c973da43b63a` (UUID).
    #[serde(
        with = "value_or_array",
        skip_serializing_if = "Vec::is_empty",
        rename = "domain"
    )]
    pub domains: Vec<String>,

    /// Used to mitigate replay attacks.
    ///
    /// Used once for a particular domain and window of time. Examples of a
    /// challenge value include: `1235abcd6789`,
    /// `79d34551-ae81-44ae-823b-6dadbab9ebd4`, and `ruby`.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub challenge: Option<String>,

    /// Arbitrary string supplied by the proof creator.
    ///
    /// One use of this field is to increase privacy by decreasing linkability
    /// that is the result of deterministically generated signatures.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nonce: Option<String>,

    /// Proof value.
    ///
    /// A string value that expresses base-encoded binary data necessary to
    /// verify the digital proof using the specified `verification_method`. The
    /// value *must* use a header and encoding as described in Section 2.4
    /// Multibase of the Controlled Identifiers v1.0 specification to express
    /// the binary data.
    ///
    /// The contents of this value are determined by a specific cryptosuite and
    /// set to the proof value generated by the Add Proof Algorithm for that
    /// cryptosuite. Alternative properties with different encodings specified
    /// by the cryptosuite *may* be used, instead of this property, to encode
    /// the data necessary to verify the digital proof.
    pub proof_value: Option<String>,

    /// Extra properties unrelated to the cryptographic suite.
    #[serde(flatten)]
    pub properties: BTreeMap<String, json_syntax::Value>,
}

impl<S> Proof<S> {
    pub fn as_ref(&self) -> ProofRef<S> {
        todo!()
    }

    pub async fn verify_with<T>(
        &self,
        verifier: impl VerificationMethodVerifier,
        claims: &T,
        params: &Parameters,
    ) -> Result<SignatureVerification, Error>
    where
        S: CryptographicSuiteFor<T>,
    {
        let mut configuration = self.as_ref();
        S::strip_proof_value(&mut configuration);

        let key = verifier
            .require_verifying_key(Some(configuration.verification_method.id().as_bytes()))
            .await?;

        let prepared = S::prepare(claims, configuration, key.key_metadata(), params).await?;

        S::verify_proof(key, prepared, self.as_ref(), params).await
    }
}

/// Data Integrity Proof.
///
/// A data integrity proof provides information about the proof mechanism,
/// parameters required to verify that proof, and the proof value itself.
#[derive(Educe, Serialize)]
#[serde(bound(serialize = "S: CryptographicSuite"))]
#[educe(Debug(bound("S: std::fmt::Debug")))]
#[educe(Clone(bound("S: Clone")))]
#[serde(rename_all = "camelCase")]
pub struct ProofRef<'a, S> {
    /// Proof context.
    #[serde(rename = "@context", default, skip_serializing_if = "Option::is_none")]
    pub context: Option<&'a ssi_json_ld::syntax::Context>,

    #[serde(flatten, with = "cryptosuite_type_ref")]
    pub r#type: &'a S,

    /// Date a creation of the proof.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created: Option<xsd_types::DateTimeStamp>,

    /// Verification method.
    pub verification_method: &'a CowVerificationMethod,

    /// Purpose of the proof.
    pub proof_purpose: ProofPurpose,

    /// Specifies when the proof expires.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expires: Option<xsd_types::DateTimeStamp>,

    #[allow(rustdoc::bare_urls)]
    /// Conveys one or more security domains in which the proof is meant to be
    /// used.
    ///
    /// A verifier SHOULD use the value to ensure that the proof was intended to
    /// be used in the security domain in which the verifier is operating. The
    /// specification of the domain parameter is useful in challenge-response
    /// protocols where the verifier is operating from within a security domain
    /// known to the creator of the proof.
    ///
    /// Example domain values include: `domain.example`` (DNS domain),
    /// `https://domain.example:8443` (Web origin), `mycorp-intranet` (bespoke
    /// text string), and `b31d37d4-dd59-47d3-9dd8-c973da43b63a` (UUID).
    #[serde(
        with = "value_or_array",
        skip_serializing_if = "<[String]>::is_empty",
        rename = "domain"
    )]
    pub domains: &'a [String],

    /// Used to mitigate replay attacks.
    ///
    /// Used once for a particular domain and window of time. Examples of a
    /// challenge value include: `1235abcd6789`,
    /// `79d34551-ae81-44ae-823b-6dadbab9ebd4`, and `ruby`.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub challenge: Option<&'a str>,

    /// Arbitrary string supplied by the proof creator.
    ///
    /// One use of this field is to increase privacy by decreasing linkability
    /// that is the result of deterministically generated signatures.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nonce: Option<&'a str>,

    /// Proof value.
    ///
    /// A string value that expresses base-encoded binary data necessary to
    /// verify the digital proof using the specified `verification_method`. The
    /// value *must* use a header and encoding as described in Section 2.4
    /// Multibase of the Controlled Identifiers v1.0 specification to express
    /// the binary data.
    ///
    /// The contents of this value are determined by a specific cryptosuite and
    /// set to the proof value generated by the Add Proof Algorithm for that
    /// cryptosuite. Alternative properties with different encodings specified
    /// by the cryptosuite *may* be used, instead of this property, to encode
    /// the data necessary to verify the digital proof.
    pub proof_value: Option<&'a str>,

    /// Extra properties unrelated to the cryptographic suite.
    #[serde(flatten)]
    pub properties: &'a BTreeMap<String, json_syntax::Value>,
}

pub mod cryptosuite_type_ref {
    use crate::CryptographicSuite;

    pub fn serialize<T: CryptographicSuite, S>(value: &&T, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        todo!()
    }
}

pub mod cryptosuite_type {
    use crate::CryptographicSuite;

    pub fn serialize<T: CryptographicSuite, S>(value: &T, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        todo!()
    }

    pub fn deserialize<'de, T: CryptographicSuite, D>(deserializer: D) -> Result<T, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        todo!()
    }
}

pub mod value_or_array {
    use serde::{Deserialize, Serialize};
    use ssi_core::OneOrMany;

    pub fn serialize<T: Serialize, S>(value: &[T], serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match value.split_first() {
            Some((first, [])) => first.serialize(serializer),
            _ => value.serialize(serializer),
        }
    }

    pub fn deserialize<'de, T: Deserialize<'de>, D>(deserializer: D) -> Result<Vec<T>, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        Ok(OneOrMany::deserialize(deserializer)?.into_vec())
    }
}
